//*************************************************************************
// tabu.c
// Purpose:  TABU SEARCH for the p-median problem. A short term memory
//           list of size MEMSIZE helps move the search away from
//           previously generated solutions.  New solutions are
//           generated by pairwise interchanges between column indices
//           in X and NOTX. An aspiration level criterion is in effect
//           as well to allow pairwise interchanges on the tabu list to
//           still be allowed if they beat the current best objective value.
//           MAXIT is the number of big iterations in which the sampling
//           takes place.
//
// Compile Command:   g++ -g -Wall tabu3.c rngs.c 
//
//*************************************************************************

#include <iostream.h>
#include <math.h>       // For the mod operator (%)
#include <iomanip.h>    // setw() operator.
#include <fstream.h>    // File i/o.
#include "rngs.h"       // Park-Miller RNG.

const int nLoc = 12;    // Number of locations.
const int memSize = 35; // Tabu step numbers.
const int maxIt = 100;  // Max iteration attempted.
const int nRow = 150;   // Number of rows of data.
const int SEED = 1;     // SEED for RNG.

typedef double Values[nRow + 1][nRow + 1];

void Config( int all[] );
void Tabu( Values Dist, int X[], int notX[], double zObj );
double ObjCheck( Values Dist, const int X[] );
long Equilikely( long a, long b );

int main ()
{
    Values Dist;               // 2D array of data.
    int X[nLoc + 1];           // Vector
    int notX[(nRow-nLoc) + 1]; // Vector
    int all[nRow + 1];         // Index array.
    double zObj;               // Objective value.
    ifstream inFile;           // Input file stream variable.
      
    // Initialize Distance Matrix

    for (int i = 0; i < nRow; i++) {
        for (int j = 0; j < nRow; j++)
            Dist[i][j] = 20000.0;
    } // for

    // Open input file
    
    inFile.open("spd150.galvao");
    
    // Fill the 2D array with data from the file.
    
    for (int i = 0; i < nRow; i++) {
        for (int j = 0; j < nRow; j++) { 
             inFile >> Dist[i][j];
//                cout << Dist[i][j] << ' ' ;
        } // for
    } // for

    // Close input file
    
    inFile.close();

    // Initialize the index array to be partitioned into X and notX.
     
    for (int i = 0; i < nRow; i++) 
        all[i] = i;
       
    // Randomly permute the index array before it is partitioned.
    
    Config(all);

    // Partition the index array into X and notX.
    
    for (int i = 0; i < nRow; i++) {
        if (i < nLoc)
            X[i] = all[i];
        else  
            notX[i-nLoc] = all[i];
    } // for

    // Compute the initial objective function value.
    
    zObj = ObjCheck(Dist, X);

    cout << "Starting p-median objective value is " << zObj << endl
         << "P-columns in the initial solution.\n";
    for (int i = 0; i < nLoc; i++)
        cout << X[i] << "  ";

    cout << "\n\nColumns 4 and 5 represent cummulative totals for "
         << "the number \n"
         << "of tabu moves and the number of moves that meet the "
         << "aspiration \n"
         << "criterion per iteration.\n" << endl
         << "Iter#    Curr Obj     Best Obj   Tabu#    Asp#" << endl;


    Tabu(Dist, X, notX, zObj);

    
    return 0;
} // main

// *******************************************************************
// void Config( int all[] );
// Purpose: Randomly permute the index array using a pseudo-random number
//          generator.
// Post:    The index array is no longer ordered.
// *******************************************************************
void Config( int all[] )   // Index array to jumble.
{
    int L, L1;  //Temp storage variables.
    
    // Initialize Random Number generator with initial seed.
    PlantSeeds(SEED);
    
    for (int M = 0; M < nRow; M++) {
        L = Equilikely(0, nRow-1);
        L1 = all[L];
        all[L] = all[M];
        all[M] = L1;
    } // for
    
} // Config()

//*******************************************************************
// long Equilikely( long a, long b );
// Purpose: Returns an equilikely distributed integer between a and b
//           inclusive. NOTE: use a < b
//******************************************************************* 
long Equilikely(long a,    // Minimum number.
                long b)    // Maximum number.
{
    
    return (a + (long) ((b - a + 1) * Random()));
    
} // Equilikely()

//*******************************************************************
// double ObjCheck( Values Dist, const int X[] );
// Purpose: Computes the sum of the row minimums of X.  This sum
//          is used to check the function value computed by Tabu().
//******************************************************************* 
double ObjCheck( Values Dist,      // 2D array of data
                 const int X[] )   // X vector.
{
    double sum = 0.0;   // Cumulative sum.
    double minVal;      // Current minimum row value.
    
    for (int i = 0; i < nRow; i++) {
        minVal = Dist[i][X[0]];
        for (int j = 1; j < nLoc; j++) {
            if (Dist[i][X[j]] < minVal)
                minVal = Dist[i][X[j]];
        }// for j
        sum = sum + minVal;
    } // for
   
    return (sum);
    
} // ObjCheck()

//*******************************************************************
// void Tabu( Values Dist, int X[], int notX[], double zObj );
// Purpose: basic tabu search with aspiration
//******************************************************************* 
void Tabu( Values Dist,          // 2D array of data.
           int X[],              // X vector
           int notX[],           // Not X vector
           double zObj )         // Initial objective value.
{ 
    double zBest = zObj;         // Best objective value.
    double zNew;                 // Interim objective value.
    double objBest;              // Interim objective value.
    double dzBest;               // Interim objective value.
    double diff;                 // Diff between current obj and orig.
    int itBest = 0;              // Best iteration.
    int temp;                    // Interim value.
    int tempX[nLoc + 1];         // Array to hold vector temp.
    int xBest[nLoc + 1];         // Array to hold the best vector.
    int sTermMem[memSize + 1][3];// 2D array for holding tabu steps.
    int stCount = 0;             // Counter
    int aspCount = 0;            // Aspiration counter.
    int nBest[2];                // Current 2 best.
    int circ;                    // Circular list index.
    int in, out;                 // 'In' is element entering X, 'out' leaves
    bool value;                  // Flag.

    
    // Initialize short term memory - the tabu steps - to 0.
    
    for (int i = 0; i < memSize; i++) {
         sTermMem[i][0] = 0;
         sTermMem[i][1] = 0;
    } // for
    
    // Search max iteration different neighborhoods
    
    for (int i = 0; i < maxIt; i++) {

        dzBest = 10000;
        for (int k = 0; k < nLoc; k++) {
            for (int m = 0; m < nRow - nLoc; m++) { 
                in = notX[m];
                out = X[k];
                
                // Copy X vector into tempX memory
                
                for (int p = 0; p < nLoc; p++)
                    tempX[p] = X[p];
   
                tempX[k] = in;
    
                // Check new objective value
                
                zNew = ObjCheck(Dist, tempX);
                diff = zNew - zObj;      

                // Check to see if the move is in STM
                
                if (diff < dzBest) {
                    value = false;
                    for (int d = 0; d < memSize; d++) {
                        if ((sTermMem[d][0] == out &&
                             sTermMem[d][1] == in) ||
                            (sTermMem[d][1] == out &&
                             sTermMem[d][0] == in))
                            value = true;
                    } // for
 
                    if (value == true && zNew < zBest) {
                        objBest = zNew;
                        dzBest = diff;
                        nBest[0] = k;
                        nBest[1] = m;
                        aspCount++;
                    } else if (value == true) { 
                        stCount++;
                    } else {
                        objBest = zNew;
                        dzBest = diff;
                        nBest[0] = k;
                        nBest[1] = m;
                    } // else
                } // if
            } // for (m)
        } // for (k)
        
        // Swap the 'in' and 'out' values in X & notX.
        
        temp = X[nBest[0]];
        X[nBest[0]] = notX[nBest[1]];
        notX[nBest[1]] = temp;
        
        // Memory updates - sTermMem is a circular list.
        
        if (i < memSize) {
            sTermMem[i][0] = X[nBest[0]];
            sTermMem[i][1] = notX[nBest[1]];
        } else {
            circ = i%memSize;
            sTermMem[circ][0] = X[nBest[0]];
            sTermMem[circ][1] = notX[nBest[1]];
        } // else
        
        zObj = objBest;
        if (zObj < zBest) {
            zBest = zObj;
            itBest = i;
            for (int y = 0; y < nLoc; y++)
                xBest[y] = X[y];
        } // if

        cout << resetiosflags(ios::right) << setiosflags(ios::left) 
             << "  " << setw(7) << i+1 << setw(13)  << zObj << setw(13)
             << zBest << setw(9) << stCount << setw(7) << aspCount << endl;
        
    } // for

    cout << "The best objective value was: " << zBest
         << "\nThe best obj value was found in iteration number "
         << itBest+1 << endl; 
    for (int i = 0; i < nLoc; i++)
        cout << xBest[i] << "  " ;
    
    cout << "\nShort Term Memory count: " << stCount << endl
         << "Aspiration count: " << aspCount << endl;
    
} // Tabu()
